#include <BWAPI.h>
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

std::vector<std::string> resnames;
std::vector<std::string> opnames;

void writeHeader()
{
	std::cout << "// This file is auto generated by BWPlanWriter.\n\n";
}

std::string removeSpaces(const std::string text)
{
	std::string result = text;
	int c = std::count(result.begin(), result.end(), ' ');
	std::remove(result.begin(), result.end(), ' ');
	result.resize(result.size()-c);
	return result;
}

std::string toCName(const std::string text)
{
	std::string result = text;
	std::replace(result.begin(), result.end(), ' ', '_');
	return result;
}

std::string getResourceName(const BWAPI::UnitType& ut)
{
	return removeSpaces("R" + ut.getName());
}

std::string getOperationName(const BWAPI::UnitType& ut)
{
	return removeSpaces("OBuild" + ut.getName());
}

std::string getTechName(const BWAPI::TechType& tt)
{
	return removeSpaces("OTech" + tt.getName());
}

std::string getTechResourceName(const BWAPI::TechType& tt)
{
	return removeSpaces("RTech" + tt.getName());
}

void writeStringList(const std::vector<std::string>& list)
{
	bool first = true;
	for (auto it : list) {
		if (!first)
			std::cout << ",\n";
		std::cout << "\t\t" << it;
		first = false;
	}
	std::cout << "\n";
}

bool isResource(const BWAPI::UnitType& ut)
{
	if (!ut.isBuilding())
		return false;
	if (ut.isHero())
		return false;
	if (ut.isSpecialBuilding())
		return false;
	if (ut.isMineralField())
		return false;
	if (ut == BWAPI::UnitTypes::Resource_Vespene_Geyser)
		return false;
	if (ut.isRefinery())
		return false;
	if (ut == BWAPI::UnitTypes::Terran_Missile_Turret)
		return false;
	if (ut == BWAPI::UnitTypes::Zerg_Nydus_Canal)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Shield_Battery)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Photon_Cannon)
		return false;
	if (ut == BWAPI::UnitTypes::Zerg_Creep_Colony)
		return false;
	if (ut == BWAPI::UnitTypes::Zerg_Spore_Colony)
		return false;
	if (ut == BWAPI::UnitTypes::Zerg_Sunken_Colony)
		return false;
	if (ut == BWAPI::UnitTypes::Terran_Supply_Depot)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Pylon)
		return false;
	if (ut == BWAPI::UnitTypes::Terran_Bunker)
		return false;
	return true;
}

void writeResForUnitType(const BWAPI::UnitType& ut)
{
	if (!isResource(ut))
		return;

	std::string resName = getResourceName(ut);

	std::cout << "DEF_RESTYPE(" << resName << ")\n";
	std::cout << "DEF_RESLOCKABLE(" << resName << ")\n";
	std::cout << "\n";

	resnames.push_back(resName);
}

bool isTechResource(const BWAPI::TechType& tt)
{
	BWAPI::UnitType what = tt.whatResearches();
	if (what == BWAPI::UnitTypes::None)
		return false;
	return true;
}

void writeResForTechType(const BWAPI::TechType& tt)
{
	if (!isTechResource(tt))
		return;

	std::string resName = getTechResourceName(tt);

	std::cout << "DEF_RESTYPE(" << resName << ")\n";
	std::cout << "\n";

	resnames.push_back(resName);
}

void writeResFile()
{
	writeHeader();
	for (auto it : BWAPI::UnitTypes::allUnitTypes())
		writeResForUnitType(it);
	for (auto it : BWAPI::TechTypes::allTechTypes())
		writeResForTechType(it);
	std::cout << "typedef TL::type_list<\n";
	writeStringList(resnames);
	std::cout << "\t> AutoResourceTypeList;\n";
}

bool isOperation(const BWAPI::UnitType& ut)
{
	if (ut.isHero())
		return false;
	if (ut.isSpecialBuilding())
		return false;
	if (ut.isMineralField())
		return false;
	if (ut == BWAPI::UnitTypes::Resource_Vespene_Geyser)
		return false;
	if (ut.getRace() != BWAPI::Races::Zerg && ut.getRace() != BWAPI::Races::Protoss && ut.getRace() != BWAPI::Races::Terran)
		return false;
	if ((ut.mineralPrice() == 1) && (ut.gasPrice() == 1))
		return false;
	if (ut.isSpell())
		return false;
	if (ut == BWAPI::UnitTypes::Terran_Siege_Tank_Siege_Mode)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Dark_Archon)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Archon)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Interceptor)
		return false;
	if (ut == BWAPI::UnitTypes::Protoss_Scarab)
		return false;
	//if (ut == BWAPI::UnitTypes::Zerg_Lurker)
	//	return false;
	if (ut == BWAPI::UnitTypes::Terran_Vulture_Spider_Mine)
		return false;
	return true;
}

void writeOpForUnitType(const BWAPI::UnitType& ut)
{
	if (!isOperation(ut))
		return;

	std::string opName  = getOperationName(ut);
	std::string resName = getResourceName(ut);
	std::string race    = ut.getRace().getName();

	std::cout << "BEGIN_DEF_OPTYPE(" << opName << ")\n";
	if (ut.isBuilding()) {
		if (ut.isAddon()) {
			auto what = ut.whatBuilds();
			std::cout << "\tLocks<1, " << getResourceName(what.first) << ">,\n";
		} else {
			std::cout << "\tLocks<1, R" << race << "Worker>,\n";
			std::cout << "\t\tCheckPoint<CSendWorkerToBuildingPlace, 45>,\n";
			if (ut.getRace() == BWAPI::Races::Zerg) {
				std::cout << "\tUnlocks<1, RZergWorker>,\n";
				std::cout << "\tConsums<1, RZergWorker>,\n";
				std::cout << "\tUnlocks<2, RZergSupply>,\n";
			}
		}
	}
	for (auto it : ut.requiredUnits())
		if (isResource(it.first)) {
			std::cout << "\tNeeds<" << it.second << ", " << getResourceName(it.first) << ">,\n";
		} else if ((it.first != BWAPI::UnitTypes::Zerg_Larva) && !it.first.isWorker()) {
			std::cout << "\t// " << it.second << " " << it.first.getName() << "\n";
		}
	if (ut.mineralPrice() > 0)
		std::cout << "\tConsums<" << ut.mineralPrice() << ", RMinerals>,\n";
	if (ut.gasPrice() > 0)
		std::cout << "\tConsums<" << ut.gasPrice() << ", RGas>,\n";
	if (ut.supplyRequired() > 0)
		std::cout << "\tLocks<" << (ut.isTwoUnitsInOneEgg() ? 2 : 1) * ut.supplyRequired() << ", R" << race << "Supply>,\n";
	if (ut.requiredTech() != BWAPI::TechTypes::None)
		std::cout << "\tNeeds<1, " << getTechResourceName(ut.requiredTech()) << ">,\n";
	if (ut.isBuilding()) {
		if (ut.isAddon()) {
			auto what = ut.whatBuilds();
			std::cout << "\t\tCheckPoint<CBuildAddon, " << ut.buildTime() << ">,\n";
			std::cout << "\tUnlocks<1, " << getResourceName(what.first) << ">,\n";
			std::cout << "\t\tCheckPoint<CBuildAddonFinished, 1>,\n";
		} else {
			if (ut.getRace() == BWAPI::Races::Protoss)
				std::cout << "\tUnlocks<1, RProtossWorker>,\n";
			std::cout << "\t\tCheckPoint<CBuildBuilding, " << ut.buildTime() << ">,\n";
			if (isResource(ut))
				std::cout << "\tProds<1, " << resName << ">,\n";
			if (ut.getRace() == BWAPI::Races::Terran)
				std::cout << "\tUnlocks<1, RTerranWorker>,\n";
			if (ut.supplyProvided() > 0)
				std::cout << "\tProds<" << ut.supplyProvided() << ", R" << race << "Supply>,\n";
			if (ut.isRefinery())
				std::cout << "\tProds<3, RGeyserWorkingPlace>,\n";
			std::cout << "\t\tCheckPoint<CBuildingFinished, 1>,\n";
		}
	} else {
		bool writeUnitFinished = false;
		auto what = ut.whatBuilds();
		if (what.first == BWAPI::UnitTypes::Zerg_Larva) {
			std::cout << "\tConsums<1, RLarva>,\n";
			std::cout << "\t\tCheckPoint<CMorphUnit, " << ut.buildTime() << ">,\n";
		} else if (ut.getRace() == BWAPI::Races::Zerg) {
			std::cout << "\t\tCheckPoint<CMorphUnit, " << ut.buildTime() << ">,\n";
		} else if (what.second != 1) {
			std::cout << "\tConsums<" << what.second << ", " << getResourceName(what.first) << ">,\n";
			std::cout << "\t\tCheckPoint<CCombineUnit, " << ut.buildTime() << ">,\n";
		} else {
			std::cout << "\tLocks<1, " << getResourceName(what.first) << ">,\n";
			std::cout << "\t\tCheckPoint<CTrainUnit, " << ut.buildTime() << ">,\n";
			std::cout << "\tUnlocks<1, " << getResourceName(what.first) << ">,\n";
			writeUnitFinished = true;
		}
		if (ut.isWorker()) {
			std::cout << "\tProds<1, R" << race << "Worker>,\n";
			writeUnitFinished = true;
		}
		if (ut.supplyProvided() > 0) {
			std::cout << "\tProds<" << ut.supplyProvided() << ", R" << race << "Supply>,\n";
			writeUnitFinished = true;
		}
		if (writeUnitFinished)
			std::cout << "\t\tCheckPoint<CUnitFinished, 1>,\n";
	}
	std::cout << "END_DEF_OPTYPE\n";
	if (ut.isBuilding())
		std::cout << "DEF_OPDETAILS(" << opName << ", BuildBuildingDetails)\n";
	else
		std::cout << "DEF_OPDETAILS(" << opName << ", BuildUnitDetails)\n";
	std::cout << "DEF_ASSOCIATION(" << opName << ", BWAPI::Race, BWAPI::Races::" << race << ")\n";
	std::cout << "DEF_ASSOCIATION(" << opName << ", BWAPI::UnitType, BWAPI::UnitTypes::" << toCName(ut.getName()) << ")\n";
	if (isResource(ut))
		std::cout << "DEF_SIMPLEREQUIREMENT(" << resName << ", " << opName << ")\n";
	std::cout << "\n";

	opnames.push_back(opName);
}

void writeOpForTechType(const BWAPI::TechType& tt)
{
	BWAPI::UnitType what = tt.whatResearches();
	if (what == BWAPI::UnitTypes::None)
		return;
		
	std::string opName = getTechName(tt);
	std::string resName = getTechResourceName(tt);

	std::cout << "BEGIN_DEF_OPTYPE(" << opName << ")\n";
	if (tt.mineralPrice() > 0)
		std::cout << "\tConsums<" << tt.mineralPrice() << ", RMinerals>,\n";
	if (tt.gasPrice() > 0)
		std::cout << "\tConsums<" << tt.gasPrice() << ", RGas>,\n";
	std::cout << "\tLocks<1, " << getResourceName(what) << ">,\n";
	std::cout << "\t\tCheckPoint<CTechStart, " << tt.researchTime() << ">,\n";
	if (isTechResource(tt))
		std::cout << "\tProds<1, " << getTechResourceName(tt) << ">,\n";
	std::cout << "\tUnlocks<1, " << getResourceName(what) << ">,\n";
	std::cout << "\t\tCheckPoint<CTechFinished, 1>,\n";
	std::cout << "END_DEF_OPTYPE\n";
	std::cout << "DEF_OPDETAILS(" << opName << ", TechDetails)\n";
	std::cout << "DEF_ASSOCIATION(" << opName << ", BWAPI::TechType, BWAPI::TechTypes::" << toCName(tt.getName()) << ")\n";
	if (isTechResource(tt))
		std::cout << "DEF_SIMPLEREQUIREMENT(" << resName << ", " << opName << ")\n";
	std::cout << "\n";
	
	opnames.push_back(opName);
}

void writeOpFile()
{
	writeHeader();
	for (auto it : BWAPI::UnitTypes::allUnitTypes())
		writeOpForUnitType(it);
	for (auto it : BWAPI::TechTypes::allTechTypes())
		writeOpForTechType(it);
	std::cout << "typedef TL::type_list<\n";
	writeStringList(opnames);
	std::cout << "\t> AutoOperationTypeList;\n";
}

int main(int argc, char *argv[])
{
	if (argc < 2) {
		std::cerr << "Use: BWPlanWriter [filename]\n";
		return 1;
	}
	
	BWAPI::BWAPI_init();

	std::string filename(argv[1]);
	if (filename == "auto-res-types.h") {
		writeResFile();
	} else if (filename == "auto-op-types.h") {
		writeOpFile();
	} else {
		std::cerr << "Unknown filename.\n";
		return 1;
	}
	return 0;
}

