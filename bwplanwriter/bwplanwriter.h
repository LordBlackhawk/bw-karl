#pragma once

#include <BWAPI.h>
#include <iostream>
#include <vector>
#include <string>

std::vector<std::string> resnames;
std::vector<std::string> opnames;

void writeHeader()
{
	std::cout << "// This file is auto generated by BWPlanWriter.\n\n";
}

std::string getResourceName(const BWAPI::UnitType& ut)
{
	return "R" + ut.getName();
}

std::string getOperationName(const BWAPI::UnitType& ut)
{
	return "OBuild" + ut.getName();
}

void writeStringList(const std::vector<std::string>& list)
{
	bool first = true;
	for (auto it : resnames) {
		if (!first)
			std::cout << ",\n";
		std::cout << "\t\t" << it;
		first = false;
	}
	std::cout << "\n";
}

void writeResForUnitType(const BWAPI::UnitType& ut)
{
	if (ut.isHero())
		return;
	if (!ut.isBuilding())
		return;

	std::string resName = getResourceName(ut);

	std::cout << "DEF_RESTYPE(" << resName << ")\n";
	std::cout << "DEF_RESLOCKABLE(" << resName << ")\n";
	std::cout << "\n";

	resnames.push_back(resName);
}

void writeResFile()
{
	writeHeader();
	for (auto it : BWAPI::UnitTypes::allUnitTypes)
		writeResForUnitType(it);
	std::cout << "typedef type_list<\n";
	writeStringList(resnames);
	std::cout << "\t> AutoResourceTypeList;\n";
}

void writeOpForUnitType(const BWAPI::UnitType& ut)
{
	if (ut.isHero())
		return;
	if (ut.isMineralField())
		return;
	if (ut == Resource_Vespene_Geyser)
		return;
	if (ut.getRace() != BWAPI::Races::Zerg && ut.getRace() != BWAPI::Races::Protoss && ut.getRace() != BWAPI::Races::Terran)
		return;

	std::string opName  = getOperationName(ut);
	std::string resName = getResourceName(ut);
	std::string race    = ut.getRace().getName();

	std::cout << "BEGIN_DEF_OPTYPE(" << opName << ")\n";
	if (ut.isBuilding()) {
		std::cout << "\tLocks<1, R" << race << "Worker>,\n";
		std::cout << "\t\tCheckPoint<CSendWorkerToBuildingPlace, 45>,\n";
		for (auto it = ut.requiredUnits())
			std::cout << "\tExists<" << it->second << ", " << getResourceName(it->first) << ">,\n";
		if (ut.getRace() == BWAPI::Races::Zerg) {
			std::cout << "\tUnlocks<1, RZergWorker>,\n";
			std::cout << "\tConsums<1, RZergWorker>,\n";
		}
	}
	if (ut.mineralPrice() > 0)
		std::cout << "\tConsums<" << ut.mineralPrice() << ", RMinerals>,\n";
	if (ut.gasPrice() > 0)
		std::cout << "\tConsums<" << ut.gasPrice() << ", RGas>,\n";
	if (ut.supplyRequired() > 0)
		std::cout << "\tLocks<" << ut.supplyRequired() << ", R" << race << "Supply>,\n";
	if (ut.isBuilding()) {
		if (ut.getRace() == BWAPI::Race::Protoss)
			std::cout << "\tUnlocks<1, RProtossWorker>,\n"
		std::cout << "\t\tCheckPoint<CBuildBuilding, 1>,\n";
		std::cout << "\tProds<1, " << resName << ">,\n";
		if (ut.getRace() == BWAPI::Race::Terran)
			std::cout << "\tUnlocks<1, RTerranWorker>,\n";
		std::cout << "\t\tCheckPoint<CBuildingFinished, " << ut.buildTime() << ">\n";
	} else {
		auto what = ut.whatBuilds();
		if (what->first == BWAPI::UnitTypes::Zerg_Larva) {
			std::cout << "\tConsums<1, RLarva>,\n";
			std::cout << "\t\tCheckPoint<CMorphUnit, 1>,\n";
		} else if (what->second != 1) {
			std::cout << "\tConsums<" << what->second << ", " << getResourceName(what->first) << ">,\n";
			std::cout << "\t\tCheckPoint<CCombineUnit, 45>,\n";
		} else {
			std::cout << "\tLocks<1, " << getResourceName(what->first) << ">,\n";
			std::cout << "\t\tCheckPoint<CTrainUnit, 1>,\n";
			std::cout << "\tUnlocks<1, " << getResourceName(what->first) << ">,\n";
		}
		if (ut.isWorker())
			std::cout << "\tProds<1, R" << race << "Worker>,\n";
		//std::cout << "\tProds<" << (ut.isTwoUnitsInOneEgg() ? 2 : 1) << ", " << resName << ">,\n";
		std::cout << "\t\tCheckPoint<CUnitFinished, " << ut.buildTime() << ">\n";
	}
	std::cout << "END_DEF_OPTYPE\n";
	std::cout << "DEF_ASSOCIATION(" << opName << ", BWAPI::Race, BWAPI::Races::" << race << ")\n";
	std::cout << "DEF_ASSOCIATION(" << opName << ", BWAPI::UnitType, BWAPI::UnitTypes::" << ut.getName() << ")\n";
	if (ut.isBuilding())
		std::cout << "DEF_SIMPLEREQUIREMENT(" << resName << ", " << opName << ")\n";
	std::cout << "\n";

	opnames.push_back(opName);
}

void writeOpFile()
{
	writeHeader();
	for (auto it : BWAPI::UnitTypes::allUnitTypes)
		writeOpForUnitType(it);
	std::cout << "typedef type_list<\n";
	writeStringList(resnames);
	std::cout << "\t> AutoOperationTypeList;\n";
}

int main(int argc, char *argv[])
{
	if (argc < 2) {
		std::cerr << "Use: BWPlanWriter [filename]\n";
		return 1;
	}

	std::string filename(argv[1]);
	if (filename == "auto-res-types.h") {
		writeResFile();
	} else if (filename == "auto-op-types.h") {
		writeOpFile();
	} else {
		std::cerr << "Unknown filename.\n";
		return 1;
	}
	return 0;
}

